<library>
    <section>
        <name>Edge</name>

        <subsection>

        <pattern>
            <name>cut-in</name>
           <code><![CDATA[
match [
    {faces=[{id=x, size=a}]},
    {faces=[]},
    {faces=[{id=x, size>a * 1.5}]}]
from shots
where a > 0.1
            ]]></code>
        </pattern>

        <pattern>
            <name>cut-away to people</name>
           <code><![CDATA[
match [
    {faces=[{id=x, size>0.2}], next = {image = {siglip < 0.8}}},
    {faces=f2},
    {faces=[{id=x, size>0.2}]}]
from shots
where len(f2) > 3 and x not in f2.id
            ]]></code>
        </pattern>

        <pattern>
            <name>cut-away to objects</name>
           <code><![CDATA[
match [
    {faces=f1, next = {image = {siglip < 0.8}}},
    {people=False},
    {faces=f3}]
from shots
where f1.id overlaps f3.id
            ]]></code>
        </pattern>

        <pattern>
            <name>intensification (same face)</name>
           <code><![CDATA[
match [s1, s2]
from shots
where some Pair #1 #2 in id_pairs(s1.faces + s2.faces):
    #2.size / #1.size > 2.0
            ]]></code>
        </pattern>


        <pattern>
            <name>intensification (multiple faces)</name>
           <code><![CDATA[
def any_gets_larger(f):
  some [#1, #2] in f.size: #2 > #1 * 2.


match [s1, s2, s3]
from shots
where (
  (median(s2.faces.size) ?? 0.) > (median(s1.faces.size) ?? 0.) * 2. and
  s1.next.image.siglip > 0.5 and
  any_gets_larger(values(group_by(.id, flatten([s2.faces, s3.faces]))))
)
            ]]></code>
        </pattern>

        <pattern>
            <name>intensification (object)</name>
           <code><![CDATA[
match [2..5 of {faces=[]} = sx]
from shots
where ((every Pair #1 #2 in pairs(sx.scale): #2 < #1) and
    (every x in most(sx.next.image.siglip): x > 0.75))
            ]]></code>
        </pattern>

        </subsection>

    </section>

    <section>
        <name>FEPs</name>
        <subsection>
            <name>cut-in</name>
            <pattern>
               <code><![CDATA[
match [
    {scale = scale1} = s1,
    {scale < scale1}+,  // s1, s2 / size relation / closer
    s3]
from shots
where (
    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>cut-away</name>
            <pattern>
                <name>to people</name>
                <code><![CDATA[
match [s1, s2, s3]
from shots
where (
  // s1, s3 / actor relation / same
  s1.actors.id overlaps s3.actors.id and

  // s1, s2 / actor relation / different
  not(s1.actors.id overlaps s2.actors.id) and
    
  // s2 / num faces / >= 2
  len(s2.faces) >= 2
)
                ]]></code>
            </pattern>
            <pattern>
                <name>to objects</name>
                <code><![CDATA[
match [
    s1,
    {actors = []}+,  // s2 / actor-count / 0
    s3]
from shots
where (
    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>intensify</name>
            <pattern>
                <name>same face</name>
                <code><![CDATA[
match [s1, s2]
from shots
where (
    // s1, s2 / actor relation, face size / same and bigger
    for-some(
        id-pairs(s1.actors + s2.actors),
        (Pair #1 #2) has (#2.size / #1.size > 1.05)
    )
)
                ]]></code>
            </pattern>
            <pattern>
                <name>multiple faces</name>
                <code><![CDATA[
match [3..6 of {} = sx]
from shots
where (
    // s1, s2 / shot scale / closer
    for-all(pairs(sx.scale), (Pair #1 #2) has (#2 < #1)) and

    // s1, s2 / face size / median face size 5% larger
    for-all(
        pairs(for x in sx: median(x.faces.size) ?? 0),
        (Pair #1 #2) has (#2 > 1.05 * #1)) and

    // seg1 / face count / >= 3
    sum(for x in take(1, sx): len(x.faces)) >= 3
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>shot reverse shot</name>
            <pattern>
                <code><![CDATA[
match [s1, s2, s3]
from shots
where let ax = [s1, s2, s3].actors: (
    // s1, s2 / actor relation / different
    not(s1.actors.id overlaps s2.actors.id) and

    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id and

    // gaze / non-direct
    for-all(
        flatten(ax.gaze),
        is-indirect-gaze) and

    // s1, s2, s3 / actor count / 1
    map(len, ax) == [1, 1, 1]
)
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>alternating shots</name>
            <pattern>
                <code><![CDATA[
match [
    {scale = scale1} = s1,
    {scale = scale2} = s2,
    {scale = scale1} = s3,  // s1, s3 / shot size / same
    {scale = scale2} = s4]  // s2, s4 / shot size / same
from shots
where (
    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id and

    // s2, s4 / actor relation / same
    s2.actors.id overlaps s4.actors.id
)
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>continuity</name>
            <pattern>
                <name>talk / dialogue</name>
                <code><![CDATA[
match [2..6 of {turn = [{id = a}]}]
from shots join speakerTurns as turn
                ]]></code>
            </pattern>
            <pattern>
                <name>spatial</name>
                <code><![CDATA[
// siglip is a technical image similarity value
match [2..6 of {next = {image = {siglip > 0.25}}}]
from shots
                ]]></code>
            </pattern>
            <pattern>
                <name>actors</name>
                <code><![CDATA[
match [2..6 of {} = s]
from shots
where (map(set, s.actors.id) matches? [a+])
                ]]></code>
            </pattern>
        </subsection>

    </section>
    <section>
        <name>Strategies</name>
        <subsection>
            <name>individualisation of...</name>
            <pattern>
                <name>elite</name>
                <code><![CDATA[
match [s1, s2]
from shots join speakerTurns as turn
where (
    s1.actors.id overlaps s2.actors.id and  // seg1 / actor-relation / same
    likely s1.place.studio and  // s1 / place / studio
    unlikely s2.place.studio and  // s2 / place / not studio
    unlikely s1.roles.reporter  and unlikely s2.roles.reporter and  // s1, s2 / actor.role / not reporter
    max(s1.turn.words.propn) ?? 0 >= 1 and  // s1 / proper noun count / >= 1
    max(s1.turn.entities.lper) ?? 0 >= 1  // s1 / NEL person count / >= 1
)
                ]]></code>
            </pattern>
            <pattern>
                <name>layperson (v1)</name>
                <code><![CDATA[
match [s1, s2]
from shots join speakerTurns as turn
where (
    unlikely s1.roles.reporter and  // s1 / actor.role / not reporter
    for-some(s2.actors.gaze, is-indirect-gaze) and  // sX / actor.gaze / indirect; Q: which actor?
    max(s1.turn.words.propn) ?? 0 >= 1 and  // t1 / proper noun / with
    max(s1.turn.words.pron) ?? 0 >= 1 and  // t2 / self-referent-pronoun / with
    is-same-place(s1.next) and  // seg1 / place-relation / same
    (s1.actors.id overlaps s2.actors.id)  // seg1 / actor-relation / same
)
                ]]></code>                
            </pattern>
            <pattern>
                <name>layperson (v2)</name>
                <code><![CDATA[
match [s1, s2]
from shots join speakerTurns as turn
where (
    unlikely s1.place.studio and // s1 / place / not studio
    unlikely s2.place.studio and // s2 / place / not studio
    s1.actors.id overlaps s2.actors.id  // seg1 / actor-relation / at least one is same
)
                ]]></code>
            </pattern>
            <pattern>
                <name>reporter</name>
                <code><![CDATA[
match [s1]
from shots join speakerTurns as turn
where (
    (likely s1.roles.reporter or likely s1.roles.anchor) and  // last shot / actor.role / reporter or anchor
    unlikely s1.place.studio  and // last shot / place / not news studio
    max(s1.turn.words.pron) ?? 0 >= 1  // t2 / self-referent-pronoun / >= 1
)
                ]]></code>                
            </pattern>
        </subsection>
        <subsection>
            <name>emotionalisation</name>
            <pattern>
                <name>facial</name>
                <code><![CDATA[
match [s1, s2]
from shots
where len(difference(
    intersection(s1.faces.emotion, s2.faces.emotion),
    ["neutral", "unknown"])) > 0
                ]]></code>
            </pattern>
            <pattern>
                <name>sentiment</name>
                <code><![CDATA[
match [s1, s2]
from speakerTurns
where s1.sentiment == s2.sentiment and s1.sentiment != "neutral"
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>dramatisation</name>
            <pattern>
                <code><![CDATA[
match [s1]
from shots
where (
    likely s1.roles.reporter and  // s1 / actor.role / reporter
    s1.movement != STATIC  // s1 / camera movement / with
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>fragmentation</name>
            <pattern>
                <name>with inserted shots</name>
                <code><![CDATA[
match [s1, s2] from shots where (
    unlikely s1.roles.reporter and  // s1 / actor.role / not reporter
    for-all(s1.actors.gaze, is-indirect-gaze) and  // s1 / actor.gaze / indirect Q: which actors?
    (s1.actors.id overlaps s2.actors.id)  // s1, s2 / actor relation / different
)
                ]]></code>                
            </pattern>
            <pattern>
                <name>with split-screen</name>
                <code><![CDATA[
match [s1]
from shots
where (
    unlikely s1.roles.reporter  // s1 / actor.role / not reporter
)
                ]]></code>                
            </pattern>
        </subsection>
    </section>
</library>
