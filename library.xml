<library>
    <section>
        <name>FEPs</name>
        <subsection>
            <name>cut-in</name>
            <pattern>
               <code><![CDATA[
match [
    {scale = scale1} = s1,
    {scale < scale1}+,  // s1, s2 / size relation / closer
    s3]
from shots
where (
    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>cut-away</name>
            <pattern>
                <name>to people</name>
                <code><![CDATA[
match [s1, s2, s3]
from shots
where (
  // s1, s3 / actor relation / same
  s1.actors.id overlaps s3.actors.id and

  // s1, s2 / actor relation / different
  not(s1.actors.id overlaps s2.actors.id) and
    
  // s2 / num faces / >= 2
  len(s2.faces) >= 2
)
                ]]></code>
            </pattern>
            <pattern>
                <name>to objects</name>
                <code><![CDATA[
match [
    s1,
    {actors = []}+,  // s2 / actor-count / 0
    s3]
from shots
where (
    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>intensify</name>
            <pattern>
                <name>same face</name>
                <code><![CDATA[
match [s1, s2]
from shots
where (
    // s1, s2 / actor relation, face size / same and bigger
    for-some(
        id-pairs(s1.actors + s2.actors),
        (Pair #1 #2) has (#2.size / #1.size > 1.05)
    )
)
                ]]></code>
            </pattern>
            <pattern>
                <name>multiple faces</name>
                <code><![CDATA[
match [3..6 of {} = sx]
from shots
where (
    // s1, s2 / shot scale / closer
    for-all(pairs(sx.scale), (Pair #1 #2) has (#2 < #1)) and

    // s1, s2 / face size / median face size 5% larger
    for-all(
        pairs(for x in sx: median(x.faces.size) ?? 0),
        (Pair #1 #2) has (#2 > 1.05 * #1)) and

    // seg1 / face count / >= 3
    sum(for x in take(1, sx): len(x.faces)) >= 3
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>shot reverse shot</name>
            <pattern>
                <code><![CDATA[
match [s1, s2, s3]
from shots
where let ax = [s1, s2, s3].actors: (
    // s1, s2 / actor relation / different
    not(s1.actors.id overlaps s2.actors.id) and

    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id and

    // gaze / non-direct
    for-all(
        flatten(ax.gaze),
        is-indirect-gaze) and

    // s1, s2, s3 / actor count / 1
    map(len, ax) == [1, 1, 1]
)
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>alternating shots</name>
            <pattern>
                <code><![CDATA[
match [
    {scale = scale1} = s1,
    {scale = scale2} = s2,
    {scale = scale1} = s3,  // s1, s3 / shot size / same
    {scale = scale2} = s4]  // s2, s4 / shot size / same
from shots
where (
    // s1, s3 / actor relation / same
    s1.actors.id overlaps s3.actors.id and

    // s2, s4 / actor relation / same
    s2.actors.id overlaps s4.actors.id
)
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>continuity</name>
            <pattern>
                <name>talk / dialogue</name>
                <code><![CDATA[
match [2..6 of {turn = [{id = a}]}]
from shots join speakerTurns as turn
                ]]></code>
            </pattern>
            <pattern>
                <name>spatial</name>
                <code><![CDATA[
// siglip is a technical image similarity value
match [2..6 of {next = {image = {siglip > 0.25}}}]
from shots
                ]]></code>
            </pattern>
            <pattern>
                <name>actors</name>
                <code><![CDATA[
match [2..6 of {} = s]
from shots
where (map(set, s.actors.id) matches? [a+])
                ]]></code>
            </pattern>
        </subsection>

    </section>
    <section>
        <name>Strategies</name>
        <subsection>
            <name>individualisation of...</name>
            <pattern>
                <name>elite</name>
                <code><![CDATA[
match [s1, s2]
from shots join speakerTurns as turn
where (
    s1.actors.id overlaps s2.actors.id and  // seg1 / actor-relation / same
    likely s1.place.studio and  // s1 / place / studio
    unlikely s2.place.studio and  // s2 / place / not studio
    unlikely s1.roles.reporter  and unlikely s2.roles.reporter and  // s1, s2 / actor.role / not reporter
    max(s1.turn.words.propn) ?? 0 >= 1 and  // s1 / proper noun count / >= 1
    max(s1.turn.entities.lper) ?? 0 >= 1  // s1 / NEL person count / >= 1
)
                ]]></code>
            </pattern>
            <pattern>
                <name>layperson (v1)</name>
                <code><![CDATA[
match [s1, s2]
from shots join speakerTurns as turn
where (
    unlikely s1.roles.reporter and  // s1 / actor.role / not reporter
    for-some(s2.actors.gaze, is-indirect-gaze) and  // sX / actor.gaze / indirect; Q: which actor?
    max(s1.turn.words.propn) ?? 0 >= 1 and  // t1 / proper noun / with
    max(s1.turn.words.pron) ?? 0 >= 1 and  // t2 / self-referent-pronoun / with
    is-same-place(s1.next) and  // seg1 / place-relation / same
    (s1.actors.id overlaps s2.actors.id)  // seg1 / actor-relation / same
)
                ]]></code>                
            </pattern>
            <pattern>
                <name>layperson (v2)</name>
                <code><![CDATA[
match [s1, s2]
from shots join speakerTurns as turn
where (
    unlikely s1.place.studio and // s1 / place / not studio
    unlikely s2.place.studio and // s2 / place / not studio
    s1.actors.id overlaps s2.actors.id  // seg1 / actor-relation / at least one is same
)
                ]]></code>
            </pattern>
            <pattern>
                <name>reporter</name>
                <code><![CDATA[
match [s1]
from shots join speakerTurns as turn
where (
    (likely s1.roles.reporter or likely s1.roles.anchor) and  // last shot / actor.role / reporter or anchor
    unlikely s1.place.studio  and // last shot / place / not news studio
    max(s1.turn.words.pron) ?? 0 >= 1  // t2 / self-referent-pronoun / >= 1
)
                ]]></code>                
            </pattern>
        </subsection>
        <subsection>
            <name>emotionalisation</name>
            <pattern>
                <name>facial</name>
                <code><![CDATA[
match [s1, s2]
from shots
where len(difference(
    intersection(s1.faces.emotion, s2.faces.emotion),
    ["neutral", "unknown"])) > 0
                ]]></code>
            </pattern>
            <pattern>
                <name>sentiment</name>
                <code><![CDATA[
match [s1, s2]
from speakerTurns
where s1.sentiment == s2.sentiment and s1.sentiment != "neutral"
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>dramatisation</name>
            <pattern>
                <code><![CDATA[
match [s1]
from shots
where (
    likely s1.roles.reporter and  // s1 / actor.role / reporter
    s1.movement != STATIC  // s1 / camera movement / with
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>fragmentation</name>
            <pattern>
                <name>with inserted shots</name>
                <code><![CDATA[
match [s1, s2] from shots where (
    unlikely s1.roles.reporter and  // s1 / actor.role / not reporter
    for-all(s1.actors.gaze, is-indirect-gaze) and  // s1 / actor.gaze / indirect Q: which actors?
    (s1.actors.id overlaps s2.actors.id)  // s1, s2 / actor relation / different
)
                ]]></code>                
            </pattern>
            <pattern>
                <name>with split-screen</name>
                <code><![CDATA[
match [s1]
from shots
where (
    unlikely s1.roles.reporter  // s1 / actor.role / not reporter
)
                ]]></code>                
            </pattern>
        </subsection>
    </section>
    <section>
        <name>Experiments</name>

        <subsection>
            <name>POV</name>            
            <pattern>
                <code><![CDATA[
match [
    {faces = f1, scale < MEDIUM_SHOT},
    {faces = f2},
    {faces = f3, scale < MEDIUM_SHOT}]
from shots
where (
    actor_relation(f1, f3) == SAME and
    actor_relation(f1, f2) == DIFFERENT
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>region</name>
            <pattern>
                <name>frameshare</name>
                <code><![CDATA[
match [
    {faces = [{id = a, region = ra, actor = True}]},
    {faces = [{id = b, region = rb, actor = True}]}]
from shots
where a != b and region_relation(ra, rb) == SAME
                ]]></code>
            </pattern>
            <pattern>
                <name>opposition</name>
                <code><![CDATA[
match [
    {faces = [{id = a, region = ra, actor = True}]},
    {faces = [{id = b, region = rb, actor = True}]}]
from shots
where a != b and region_relation(ra, rb) == DIFFERENT
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>enhancement</name>

            <pattern>
                <name>thematics enhancement</name>
                <comment>Hannover Technical Feature A, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.action.kineticsvmae > 0.95 and s2.next.action.kineticsvmae > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>thematics enhancement</name>
                <comment>Hannover Technical Feature B, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.action.ssv2vmae > 0.95 and s2.next.action.ssv2vmae > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>thematics enhancement</name>
                <comment>Hannover Technical Feature C, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.action.kineticsxclip > 0.95 and s2.next.action.kineticsxclip > 0.95
                ]]></code>
            </pattern>

            <pattern>
                <name>ambience enhancement</name>
                <comment>Hannover Technical Feature A, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.audio.wav2vec2 > 0.95 and s2.next.audio.wav2vec2 > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>ambience enhancement</name>
                <comment>Hannover Technical Feature B, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.audio.beats > 0.95 and s2.next.audio.beats > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>ambience enhancement</name>
                <comment>Hannover Technical Feature C, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.audio.whisper > 0.95 and s2.next.audio.whisper > 0.95
                ]]></code>
            </pattern>

        </subsection>
    </section>
</library>
