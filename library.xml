<library>
    <section>
        <name>FEPs</name>
        <subsection>
            <name>cut-in</name>
            <pattern>
               <code><![CDATA[
match [
    {actors = a1, scale = s1},
    // s1, s2 / size relation / closer
    {scale < s1}+,
    {actors = a2}]
from shots
where (
    // s1, s3 / actor relation / same
    a1.id overlaps a2.id
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>cut-away</name>
            <pattern>
                <name>to people</name>
                <code><![CDATA[
match [
    {actors = a1},
    {actors = a2},
    {actors = a3}]
from shots
where (
    # s1, s3 / actor relation / same
    a1.id overlaps a3.id and

    # s1, s2 / actor relation / different
    not(a1.id overlaps a2.id) and

    # s2 / num faces / >= 2
    len(a2) >= 2)
                ]]></code>
            </pattern>
            <pattern>
                <name>to objects</name>
                <code><![CDATA[
match [
    {actors = a1},
    # s2 / actor-count / 0
    {actors = []}+,
    {actors = a3}]
from shots
where (
    # s1, s3 / actor relation / same
    a1.id overlaps a3.id
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>intensify</name>
            <pattern>
                <name>same face</name>
                <code><![CDATA[
@operator(infix, left, 4)
@macro def for-any(f, xs):
  any(lambda x: match x: case [x1, x2]: f, xs)

def values(xs: List Rule a b) -> List b:
    for x in xs:
        match x:
            case Rule key value:
                value

@macro
def id-pairs(xs):
    filter(lambda x: len(x) == 2,
        values(groupBy(lambda x: x.id, xs)))

match [
    {actors = a1},
    {actors = a2}]
from shots
where (
    # s1, s2 / actor relation, face size / same and bigger
    (x2.size / x1.size > 1.05) for-any id-pairs(a1 + a2)
)
                ]]></code>
            </pattern>
            <pattern>
                <name>multiple faces</name>
                <code><![CDATA[
@operator(infix, left, 4)
@macro def for-all(f, xs):
  all(lambda x: match x: case [x1, x2]: f, xs)

@operator(infix, left, 7)
def maybe(lhs, rhs):
    match lhs:
        case Just x:
            x
        case Nothing:
            rhs

match [3..6 of {} = seq]
from shots
where (
    # s1, s2 / shot scale / closer
    (x2 < x1) for-all pairs(seq.scale) and

    # s1, s2 / face size / median face size 5% larger
    (x2 > 1.05 * x1) for-all pairs(for x in seq: median(x.faces.size) maybe 0) and

    # seg1 / face count / >= 3
    sum(for x in take(1, seq): len(x.faces)) >= 3
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>shot reverse shot</name>
            <pattern>
                <code><![CDATA[
match [
    {actors = a1},
    {actors = a2},
    {actors = a3}]
from shots
where (
    # s1, s2 / actor relation / different
    not(a1.id overlaps a2.id) and

    # s1, s3 / actor relation / same
    a1.id overlaps a3.id and

    # gaze / non-direct
    all(is_indirect_gaze, flatten([a1.gaze, a2.gaze, a3.gaze])) and

    # s1, s2, s3 / actor count / 1
    len(a1) == 1 and len(a2) == 1 and len(a3) == 1
)                
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>alternating shots</name>
            <pattern>
                <code><![CDATA[
match [
    {actors = a1, scale = s1},
    {actors = a2, scale = s2},
    {actors = a3, scale = s1},  # s1, s3 / shot size / same
    {actors = a4, scale = s2}]  # s2, s4 / shot size / same
from shots
where (
    # s1, s3 / actor relation / same
    a1.id overlaps a3.id and

    # s2, s4 / actor relation / same
    a2.id overlaps a4.id
)
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>continuity</name>
            <pattern>
                <name>talk / dialogue</name>
                <code><![CDATA[
match [2... of {st = [{id = a}]}]
from shots join speakerTurns as st
                ]]></code>
            </pattern>
            <pattern>
                <name>spatial</name>
                <code><![CDATA[
# siglip is a technical image similarity value
match [2... of {next = {image = {siglip > 0.25}}}]
from shots
                ]]></code>
            </pattern>
            <pattern>
                <name>actors</name>
                <code><![CDATA[
match [2... of {} = s]
from shots
where (map(set, s.actors.id) matches? [a+])
                ]]></code>
            </pattern>
        </subsection>

    </section>
    <section>
        <name>Strategies</name>
        <subsection>
            <name>individualisation of...</name>
            <pattern>
                <name>elite</name>
                <code><![CDATA[
match [
    {actors = a1, place = p1, roles = r1, st = st1},
    {actors = a2, place = p2, roles = r2}
] from shots join speakerTurns as st
where (
    len(intersection(a1.id, a2.id)) >= 1 and  # seg1 / actor-relation / same
    p1.studio > 0.5 and  # s1 / place / studio
    p2.studio < 0.5 and  # s2 / place / not studio
    r1.reporter < 0.5  and r2.reporter < 0.5 and  # s1, s2 / actor.role / not reporter
    max(st1.words.propn) >= 1 and  # s1 / proper noun count / >= 1
    max(st1.entities.lper) >= 1  # s1 / NEL person count / >= 1
)
                ]]></code>
            </pattern>
            <pattern>
                <name>layperson (v1)</name>
                <code><![CDATA[
match [
    {actors = a1, place = p1, roles = r1, st = st1, next = nx1},
    {actors = a2, place = p2, roles = r2, st = st2}
] from shots join speakerTurns as st
where (
    r1.reporter < 0.5 and  # s1 / actor.role / not reporter
    any(is_indirect_gaze, a2.gaze) and  # sX / actor.gaze / indirect; Q: which actor?
    max(st1.words.propn) >= 1 and  # t1 / proper noun / with
    max(st1.words.pron) >= 1 and  # t2 / self-referent-pronoun / with
    is_same_place(nx1)  # seg1 / place-relation / same
    len(intersection(a1.id, a2.id)) >= 1  # seg1 / actor-relation / same
)                ]]></code>                
            </pattern>
            <pattern>
                <name>layperson (v2)</name>
                <code><![CDATA[
match [
    {actors = a1, place = p1, roles = r1, st = st1}
] from shots join speakerTurns as st
where (
    (r1.reporter > 0.5 or r1.anchor > 0.5) and  # last shot / actor.role / reporter or anchor
    p1.studio < 0.5  and # last shot / place / not news studio
    max(st1.words.pron) >= 1  # t2 / self-referent-pronoun / >= 1
)
                ]]></code>
            </pattern>
            <pattern>
                <name>reporter</name>
                <code><![CDATA[
match [
    {actors = a1, place = p1, roles = r1, st = st1}
] from shots join speakerTurns as st
where (
    (r1.reporter > 0.5 or r1.anchor > 0.5) and  # last shot / actor.role / reporter or anchor
    p1.studio < 0.5  and # last shot / place / not news studio
    max(st1.words.pron) >= 1  # t2 / self-referent-pronoun / >= 1
)                    
                ]]></code>                
            </pattern>
        </subsection>
        <subsection>
            <name>emotionalisation</name>
            <pattern>
                <name>facial</name>
                <code><![CDATA[
match [
    {faces = f1},
    {faces = f2}
] from shots where len(difference(
    intersection(f1.emotion, f2.emotion),
    ["neutral", "unknown"])) > 0
                ]]></code>
            </pattern>
            <pattern>
                <name>sentiment</name>
                <code><![CDATA[
match [
    {sentiment = s1},
    {sentiment = s2}
] from speakerTurns where s1 == s2 and s1 != "neutral"
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>dramatisation</name>
            <pattern>
                <code><![CDATA[
match [
    {roles = r1, movement = m1}
] from shots where (
    r1.reporter > 0.5 and  # s1 / actor.role / reporter
    m1 != STATIC  # s1 / camera movement / with
)
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>fragmentation</name>
            <pattern>
                <name>with inserted shots</name>
                <code><![CDATA[
match [
    {actors = a1, roles = r1, movement = m1},
    {actors = a2}
] from shots where (
    r1.reporter < 0.5 and  # s1 / actor.role / not reporter
    all(is_indirect_gaze, a1.gaze) and  # s1 / actor.gaze / indirect Q: which actors?
    len(intersection(a1.id, a2.id)) == 0  # s1, s2 / actor relation / different
)
                ]]></code>                
            </pattern>
            <pattern>
                <name>with split-screen</name>
                <code><![CDATA[
match [
    {roles = r1}
] from shots where (
    r1.reporter < 0.5  # s1 / actor.role / not reporter
)
                ]]></code>                
            </pattern>
        </subsection>
    </section>
    <section>
        <name>Experiments</name>

        <subsection>
            <name>POV</name>            
            <pattern>
                <code><![CDATA[
match [
    {faces = f1, scale < MEDIUM_SHOT},
    {faces = f2},
    {faces = f3, scale < MEDIUM_SHOT}]
from shots
where actor_relation(f1, f3) == SAME and actor_relation(f1, f2) == DIFFERENT
                ]]></code>
            </pattern>
        </subsection>
        <subsection>
            <name>region</name>
            <pattern>
                <name>frameshare</name>
                <code><![CDATA[
match [
    {faces = [{id = a, region = ra, actor = True}]},
    {faces = [{id = b, region = rb, actor = True}]}]
from shots
where a != b and region_relation(ra, rb) == SAME
                ]]></code>
            </pattern>
            <pattern>
                <name>opposition</name>
                <code><![CDATA[
match [
    {faces = [{id = a, region = ra, actor = True}]},
    {faces = [{id = b, region = rb, actor = True}]}]
from shots
where a != b and region_relation(ra, rb) == DIFFERENT
                ]]></code>
            </pattern>
        </subsection>

        <subsection>
            <name>enhancement</name>

            <pattern>
                <name>thematics enhancement</name>
                <comment>Hannover Technical Feature A, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.action.kineticsvmae > 0.95 and s2.next.action.kineticsvmae > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>thematics enhancement</name>
                <comment>Hannover Technical Feature B, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.action.ssv2vmae > 0.95 and s2.next.action.ssv2vmae > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>thematics enhancement</name>
                <comment>Hannover Technical Feature C, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.action.kineticsxclip > 0.95 and s2.next.action.kineticsxclip > 0.95
                ]]></code>
            </pattern>

            <pattern>
                <name>ambience enhancement</name>
                <comment>Hannover Technical Feature A, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.audio.wav2vec2 > 0.95 and s2.next.audio.wav2vec2 > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>ambience enhancement</name>
                <comment>Hannover Technical Feature B, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.audio.beats > 0.95 and s2.next.audio.beats > 0.95
                ]]></code>
            </pattern>
            <pattern>
                <name>ambience enhancement</name>
                <comment>Hannover Technical Feature C, Unknown Thresholds</comment>
                <code><![CDATA[
match [s1, s2, {}]
from shots
where s1.next.audio.whisper > 0.95 and s2.next.audio.whisper > 0.95
                ]]></code>
            </pattern>

        </subsection>
    </section>
</library>
